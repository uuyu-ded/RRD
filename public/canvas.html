<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RoundRobinDraw</title>
    <link rel="stylesheet" href="canvas.css">
</head>
<body>
    <div class="left-panel">
        <!-- Add a div to display the prompt -->
        <div id="promptDisplay" class="prompt-display"></div>
        <canvas id="drawingCanvas" width="900" height="600"></canvas>
    </div>
    <div class="right-panel">
        <div class="title-box">RoundRobinDraw</div>
        <div class="timer-box" id="timer">Time: 60s</div>

        <!-- Tools Grid -->
        <div class="toolbar-section">
            <h3>Tools</h3>
            <div class="toolbar">
                <button class="icon-button" onclick="setTool('brush')" id="brushButton">
                    <img src="images/brush-icon.png" alt="Brush">
                </button>
                <button class="icon-button" onclick="setTool('eraser')" id="eraserButton">
                    <img src="images/eraser-icon.png" alt="Eraser">
                </button>
                <button class="icon-button" onclick="setTool('rectangle')" id="rectangleButton">
                    <img src="images/rectangle-icon.png" alt="Rectangle">
                </button>
                <button class="icon-button" onclick="setTool('circle')" id="circleButton">
                    <img src="images/circle-icon.png" alt="Circle">
                </button>
            </div>
        </div>

        <!-- Size Adjustment -->
        <div class="size-adjustment">
            <label for="brushSize">Size</label>
            <input type="range" id="brushSize" min="1" max="30" value="5" onchange="setSize(this.value)">
        </div>

        <!-- Color Picker -->
        <div class="color-picker">
            <label for="colorPicker">Color Picker</label>
            <input type="color" id="colorPicker" onchange="setColor(this.value)">
        </div>

        <!-- Undo and Redo Buttons -->
        <div class="toolbar-section">
            <div class="toolbar">
                <button class="icon-button" onclick="undo()" id="undoButton">
                    <img src="images/undo-icon.png" alt="Undo">
                </button>
                <button class="icon-button" onclick="redo()" id="redoButton">
                    <img src="images/redo-icon.png" alt="Redo">
                </button>
            </div>
        </div>

        <!-- Clear Button -->
        <button onclick="clearCanvas()" id="clearButton">Clear</button>

        <!-- Submit Button -->
        <button class="submit-button" onclick="submitDrawing()" id="submitButton">Submit</button>
    </div>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const roomCode = urlParams.get('room');
        const isMemoryMode = urlParams.get('mode') === 'memory';
        const round = urlParams.get('round') || 1;

        const promptDisplay = document.getElementById('promptDisplay');
        if (isMemoryMode) {
        promptDisplay.textContent = `Memory Mode - Round ${round}`;
        } else {
        // Only fetch prompt for non-memory modes
        fetch(`/getRandomPrompt?room=${roomCode}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                promptDisplay.textContent = `Prompt: ${data.prompt}`;
            }
        })
        .catch(error => {
            console.error('Error fetching prompt:', error);
        });
        }
        
        const canvas = document.getElementById("drawingCanvas");
        const ctx = canvas.getContext("2d");
        let painting = false, tool = "brush", color = "#000000", size = 5;
        let startX, startY, endX, endY, timer = 160, isDrawingShape = false;
        let freehandPaths = [], shapes = [];
        let history = [], currentHistoryIndex = -1;
        let actionSequence = 0;

        function saveState() {
            if (currentHistoryIndex < history.length - 1) history.splice(currentHistoryIndex + 1);
            history.push({ freehandPaths: JSON.parse(JSON.stringify(freehandPaths)), shapes: JSON.parse(JSON.stringify(shapes)), actionSequence });
            currentHistoryIndex = history.length - 1; updateUndoRedoButtons();
        }

        function undo() {
            if (currentHistoryIndex >= 0) {
                currentHistoryIndex--;
                if (currentHistoryIndex >= 0) {
                    const st = history[currentHistoryIndex]; freehandPaths = JSON.parse(JSON.stringify(st.freehandPaths)); shapes = JSON.parse(JSON.stringify(st.shapes)); actionSequence = st.actionSequence;
                } else { freehandPaths = []; shapes = []; actionSequence = 0; }
                redrawCanvas(); updateUndoRedoButtons();
            }
        }

        function redo() {
            if (currentHistoryIndex < history.length - 1) {
                currentHistoryIndex++;
                const st = history[currentHistoryIndex]; freehandPaths = JSON.parse(JSON.stringify(st.freehandPaths)); shapes = JSON.parse(JSON.stringify(st.shapes)); actionSequence = st.actionSequence;
                redrawCanvas(); updateUndoRedoButtons();
            }
        }

        function updateUndoRedoButtons() {
            document.getElementById("undoButton").disabled = currentHistoryIndex < 0;
            document.getElementById("redoButton").disabled = currentHistoryIndex >= history.length - 1;
        }

        function setTool(t) { tool = t; }
        function setColor(c) { color = c; }
        function setSize(s) { size = s; }

        function startPosition(e) {
            if (timer <= 0) return;
            painting = true;
            startX = e.clientX - canvas.getBoundingClientRect().left;
            startY = e.clientY - canvas.getBoundingClientRect().top;
            if (tool === 'brush' || tool === 'eraser') {
                freehandPaths.push({ type: 'freehand', points: [{ x: startX, y: startY }], color: tool==='eraser'? '#FFFFFF': color, size, seq: actionSequence++ });
            } else isDrawingShape = true;
        }

        function endPosition() {
            if (isDrawingShape) {
                if (tool==='rectangle') shapes.push({ type: 'rectangle', x: startX, y: startY, width: endX-startX, height: endY-startY, color, size, seq: actionSequence++ });
                else if (tool==='circle') {
                    const radius=Math.hypot(endX-startX,endY-startY);
                    shapes.push({ type:'circle', x:startX, y:startY, radius, color, size, seq: actionSequence++ });
                }
                isDrawingShape=false;
            }
            painting=false; ctx.beginPath(); saveState();
        }

        function draw(e) {
            if (!painting) return;
            const x = e.clientX - canvas.getBoundingClientRect().left;
            const y = e.clientY - canvas.getBoundingClientRect().top;
            if (tool==='brush'||tool==='eraser') {
                const path = freehandPaths[freehandPaths.length-1]; path.points.push({ x, y });
                ctx.strokeStyle = path.color; ctx.lineWidth=path.size; ctx.lineCap="round";
                ctx.lineTo(x,y); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x,y);
            } else { endX=x; endY=y; drawShapePreview(); }
        }

        function drawShapePreview() {
            if (!isDrawingShape) return; redrawCanvas(); ctx.strokeStyle=color; ctx.lineWidth=size;
            if (tool==='rectangle') ctx.strokeRect(startX,startY,endX-startX,endY-startY);
            else { ctx.beginPath(); ctx.arc(startX,startY,Math.hypot(endX-startX,endY-startY),0,2*Math.PI); ctx.stroke(); }
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const all = [...freehandPaths, ...shapes].sort((a,b)=>a.seq-b.seq);
            all.forEach(obj=>{
                if (obj.type==='freehand') {
                    ctx.strokeStyle=obj.color; ctx.lineWidth=obj.size; ctx.lineCap="round"; ctx.beginPath();
                    obj.points.forEach((pt,i)=>{ if(i===0) ctx.moveTo(pt.x,pt.y); else ctx.lineTo(pt.x,pt.y); }); ctx.stroke();
                } else if(obj.type==='rectangle') {
                    ctx.strokeStyle=obj.color; ctx.lineWidth=obj.size; ctx.strokeRect(obj.x,obj.y,obj.width,obj.height);
                } else if(obj.type==='circle') {
                    ctx.strokeStyle=obj.color; ctx.lineWidth=obj.size; ctx.beginPath(); ctx.arc(obj.x,obj.y,obj.radius,0,2*Math.PI); ctx.stroke();
                }
            });
        }

        function clearCanvas() { ctx.clearRect(0,0,canvas.width,canvas.height); freehandPaths=[]; shapes=[]; actionSequence=0; saveState(); }
        function submitDrawing(){alert("Drawing submitted!");}
        function startTimer(){ 
            const timerEl=document.getElementById("timer"); 
            const countdown=setInterval(()=>{ 
                if(timer>0){timer--;timerEl.textContent=`Time: ${timer}s`; 

                } else {
                    clearInterval(countdown);
                    alert("Time's up!");[...document.querySelectorAll('button,input')].forEach(el=>{if(el.id!=='submitButton')el.disabled=true;

                    });
                }
            },1000);
        }        
        canvas.addEventListener("mousedown",startPosition);
        canvas.addEventListener("mouseup",endPosition);
        canvas.addEventListener("mousemove",draw);
        startTimer();

if (isMemoryMode) {
    // Adjust timer for memory mode
    timer = 120; // 1 minute for memory mode drawing
    
    // Update prompt display for memory mode
    const promptDisplay = document.getElementById('promptDisplay');
    promptDisplay.textContent = `Memory Mode - Round ${round}`;
    
    // Modify submit button for memory mode
    document.getElementById('submitButton').addEventListener('click', () => {
        const canvasData = canvas.toDataURL();
        const playerName = "currentPlayerName";
        
        // Send drawing to server
        fetch(`/submitMemoryDrawing`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 
                room: roomCode, 
                round,
                drawing: canvasData, playerName 
            }),
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Redirect to viewing phase
                window.location.href = `memory.html?room=${roomCode}&viewing=true`;
            }
            });
        });
        // Auto-submit if time runs out
        const timerInterval = setInterval(() => {
            if (timer <= 0) {
            clearInterval(timerInterval);
            document.getElementById('submitButton').click();
            }
        }, 1000);
    }
    </script>
</body>
</html>