"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const chalk_1 = __importDefault(require("chalk"));
const resolve_from_1 = __importDefault(require("resolve-from"));
const vueResolver_1 = require("./vueResolver");
const utils_1 = require("./utils");
const slash_1 = __importDefault(require("slash"));
const debug = require('debug')('vite:resolve');
const idToEntryMap = new Map();
const idToFileMap = new Map();
const webModulesMap = new Map();
const moduleRE = /^\/@modules\//;
const getDebugPath = (root, p) => {
    const relative = path_1.default.relative(root, p);
    return relative.startsWith('..') ? p : relative;
};
// plugin for resolving /@modules/:id requests.
exports.moduleResolvePlugin = ({ root, app }) => {
    app.use(async (ctx, next) => {
        if (!moduleRE.test(ctx.path)) {
            return next();
        }
        const id = ctx.path.replace(moduleRE, '');
        ctx.type = 'js';
        const serve = async (id, file, type) => {
            idToFileMap.set(id, file);
            debug(`(${type}) ${id} -> ${getDebugPath(root, file)}`);
            // cached read sets etag, body and status on ctx so there is no need
            // to go further to other middlewares.
            await utils_1.cachedRead(ctx, file);
        };
        // special handling for vue's runtime.
        if (id === 'vue') {
            return serve(id, vueResolver_1.resolveVue(root).browser, 'vue');
        }
        // already resolved and cached
        const cachedPath = idToFileMap.get(id);
        if (cachedPath) {
            return serve(id, cachedPath, 'cached');
        }
        // package entries need redirect to ensure correct relative import paths
        // check if the entry was already resolved
        const cachedEntry = idToEntryMap.get(id);
        if (cachedEntry) {
            debug(`(cached redirect) ${id} -> ${cachedEntry}`);
            return ctx.redirect(slash_1.default(path_1.default.join(ctx.path, cachedEntry)));
        }
        // resolve from web_modules
        try {
            const webModulePath = await resolveWebModule(root, id);
            if (webModulePath) {
                return serve(id, webModulePath, 'web_modules');
            }
        }
        catch (e) {
            console.error(chalk_1.default.red(`[vite] Error while resolving web_modules with id "${id}":`));
            console.error(e);
            ctx.status = 404;
        }
        const entryPoint = await resolveNodeModuleEntry(root, id);
        if (entryPoint) {
            return ctx.redirect(slash_1.default(path_1.default.join(ctx.path, entryPoint)));
        }
        // resolve from node_modules
        try {
            // we land here after a module entry redirect
            // or a direct deep import like 'foo/bar/baz.js'.
            const file = resolve_from_1.default(root, id);
            return serve(id, file, 'node_modules');
        }
        catch (e) {
            console.error(chalk_1.default.red(`[vite] Error while resolving node_modules with id "${id}":`));
            console.error(e);
            ctx.status = 404;
        }
    });
};
async function resolveWebModule(root, id) {
    const webModulePath = webModulesMap.get(id);
    if (webModulePath) {
        return webModulePath;
    }
    const importMapPath = path_1.default.join(root, 'web_modules', 'import-map.json');
    if (await fs_extra_1.default.pathExists(importMapPath)) {
        const importMap = require(importMapPath);
        if (importMap.imports) {
            const webModulesDir = path_1.default.dirname(importMapPath);
            Object.entries(importMap.imports).forEach(([key, val]) => webModulesMap.set(key, path_1.default.join(webModulesDir, val)));
            return webModulesMap.get(id);
        }
    }
}
async function resolveNodeModuleEntry(root, id) {
    let pkgPath;
    try {
        // see if the id is a valid package name
        pkgPath = resolve_from_1.default(root, `${id}/package.json`);
    }
    catch (e) { }
    if (pkgPath) {
        // if yes, resolve entry file
        const pkg = require(pkgPath);
        const entryPoint = pkg.module || pkg.main || 'index.js';
        debug(`(redirect) ${id} -> ${entryPoint}`);
        idToEntryMap.set(id, entryPoint);
        return entryPoint;
    }
}
