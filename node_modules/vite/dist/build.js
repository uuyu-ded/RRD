"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const vueResolver_1 = require("./vueResolver");
const resolve_from_1 = __importDefault(require("resolve-from"));
const chalk_1 = __importDefault(require("chalk"));
const resolver_1 = require("./resolver");
const buildPluginResolve_1 = require("./buildPluginResolve");
const buildPluginHtml_1 = require("./buildPluginHtml");
const buildPluginCss_1 = require("./buildPluginCss");
const buildPluginAsset_1 = require("./buildPluginAsset");
const writeColors = {
    [0 /* JS */]: chalk_1.default.cyan,
    [1 /* CSS */]: chalk_1.default.magenta,
    [2 /* ASSET */]: chalk_1.default.green,
    [3 /* HTML */]: chalk_1.default.blue
};
/**
 * Bundles the app for production.
 * Returns a Promise containing the build result.
 */
async function build(options = {}) {
    process.env.NODE_ENV = 'production';
    const start = Date.now();
    const { root = process.cwd(), base = '/', cdn = !vueResolver_1.resolveVue(root).hasLocalVue, outDir = path_1.default.resolve(root, 'dist'), assetsDir = 'assets', assetsInlineLimit = 4096, resolvers = [], srcRoots = [], rollupInputOptions = {}, rollupOutputOptions = {}, rollupPluginVueOptions = {}, emitIndex = true, emitAssets = true, write = true, minify = true, silent = false } = options;
    const indexPath = emitIndex ? path_1.default.resolve(root, 'index.html') : null;
    const publicBasePath = base.replace(/([^/])$/, '$1/'); // ensure ending slash
    const resolvedAssetsPath = path_1.default.join(outDir, assetsDir);
    const cssFileName = 'style.css';
    const resolver = resolver_1.createResolver(root, resolvers);
    const { htmlPlugin, renderIndex } = await buildPluginHtml_1.createBuildHtmlPlugin(indexPath, publicBasePath, assetsDir, assetsInlineLimit, resolver);
    // lazy require rollup so that we don't load it when only using the dev server
    // importing it just for the types
    const rollup = require('rollup').rollup;
    const bundle = await rollup({
        input: path_1.default.resolve(root, 'index.html'),
        preserveEntrySignatures: false,
        ...rollupInputOptions,
        plugins: [
            // user plugins
            ...(rollupInputOptions.plugins || []),
            // vite:resolve
            buildPluginResolve_1.createBuildResolvePlugin(root, cdn, [root, ...srcRoots], resolver),
            // vite:html
            ...(htmlPlugin ? [htmlPlugin] : []),
            // vue
            require('rollup-plugin-vue')({
                transformAssetUrls: {
                    includeAbsolute: true
                },
                // TODO: for now we directly handle pre-processors in rollup-plugin-vue
                // so that we don't need to install dedicated rollup plugins.
                // In the future we probably want to still use rollup plugins so that
                // preprocessors are also supported by importing from js files.
                preprocessStyles: true,
                preprocessCustomRequire: (id) => require(resolve_from_1.default(root, id)),
                // TODO proxy cssModules config
                ...rollupPluginVueOptions
            }),
            require('@rollup/plugin-json')(),
            require('@rollup/plugin-node-resolve')({
                rootDir: root
            }),
            require('@rollup/plugin-replace')({
                'process.env.NODE_ENV': '"production"',
                __DEV__: 'false'
            }),
            // vite:css
            buildPluginCss_1.createBuildCssPlugin(root, publicBasePath, assetsDir, cssFileName, minify, assetsInlineLimit),
            // vite:asset
            buildPluginAsset_1.createBuildAssetPlugin(publicBasePath, assetsDir, assetsInlineLimit),
            // minify with terser
            // modules: true and toplevel: true are implied with format: 'es'
            ...(minify ? [require('rollup-plugin-terser').terser()] : [])
        ],
        onwarn(warning, warn) {
            if (warning.code !== 'CIRCULAR_DEPENDENCY') {
                warn(warning);
            }
        }
    });
    const { output } = await bundle.generate({
        format: 'es',
        ...rollupOutputOptions
    });
    const indexHtml = renderIndex(root, cdn, cssFileName, output);
    if (write) {
        const cwd = process.cwd();
        const writeFile = async (filepath, content, type) => {
            await fs_extra_1.default.ensureDir(path_1.default.dirname(filepath));
            await fs_extra_1.default.writeFile(filepath, content);
            if (!silent) {
                console.log(`${chalk_1.default.gray(`[write]`)} ${writeColors[type](path_1.default.relative(cwd, filepath))} ${(content.length / 1024).toFixed(2)}kb`);
            }
        };
        await fs_extra_1.default.remove(outDir);
        await fs_extra_1.default.ensureDir(outDir);
        for (const chunk of output) {
            if (chunk.type === 'chunk') {
                // write chunk
                const filepath = path_1.default.join(resolvedAssetsPath, chunk.fileName);
                await writeFile(filepath, chunk.code, 0 /* JS */);
            }
            else if (emitAssets) {
                // write asset
                const filepath = path_1.default.join(resolvedAssetsPath, chunk.fileName);
                await writeFile(filepath, chunk.source, chunk.fileName.endsWith('.css') ? 1 /* CSS */ : 2 /* ASSET */);
            }
        }
        // write html
        if (indexHtml && emitIndex) {
            await writeFile(path_1.default.join(outDir, 'index.html'), indexHtml, 3 /* HTML */);
        }
    }
    !silent &&
        console.log(`Build completed in ${((Date.now() - start) / 1000).toFixed(2)}s.`);
    return {
        assets: output,
        html: indexHtml
    };
}
exports.build = build;
/**
 * Bundles the app in SSR mode.
 * - All Vue dependencies are automatically externalized
 * - Imports to dependencies are compiled into require() calls
 * - Templates are compiled with SSR specific optimizations.
 */
async function ssrBuild(options = {}) {
    const { rollupInputOptions, rollupOutputOptions, rollupPluginVueOptions } = options;
    return build({
        ...options,
        rollupPluginVueOptions: {
            ...rollupPluginVueOptions,
            target: 'node'
        },
        rollupInputOptions: {
            ...rollupInputOptions,
            external: resolveExternal(rollupInputOptions && rollupInputOptions.external)
        },
        rollupOutputOptions: {
            ...rollupOutputOptions,
            format: 'cjs',
            exports: 'named'
        },
        emitIndex: false,
        emitAssets: false,
        minify: false
    });
}
exports.ssrBuild = ssrBuild;
function resolveExternal(userExternal) {
    const required = ['vue', /^@vue\//];
    if (!userExternal) {
        return required;
    }
    if (Array.isArray(userExternal)) {
        return [...required, ...userExternal];
    }
    else if (typeof userExternal === 'function') {
        return (src, importer, isResolved) => {
            if (src === 'vue' || /^@vue\//.test(src)) {
                return true;
            }
            return userExternal(src, importer, isResolved);
        };
    }
    else {
        return [...required, userExternal];
    }
}
