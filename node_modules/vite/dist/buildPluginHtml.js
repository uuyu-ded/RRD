"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const utils_1 = require("./utils");
const vueResolver_1 = require("./vueResolver");
const buildPluginAsset_1 = require("./buildPluginAsset");
const compiler_dom_1 = require("@vue/compiler-dom");
const magic_string_1 = __importDefault(require("magic-string"));
exports.createBuildHtmlPlugin = async (indexPath, publicBasePath, assetsDir, inlineLimit, resolver) => {
    if (!indexPath || !(await fs_extra_1.default.pathExists(indexPath))) {
        return {
            renderIndex: (...args) => '',
            htmlPlugin: null
        };
    }
    const rawHtml = await fs_extra_1.default.readFile(indexPath, 'utf-8');
    let { html: processedHtml, js } = await compileHtml(rawHtml, publicBasePath, assetsDir, inlineLimit, resolver);
    const htmlPlugin = {
        name: 'vite:html',
        async load(id) {
            if (id === indexPath) {
                return js;
            }
        }
    };
    const injectCSS = (html, filename) => {
        const tag = `<link rel="stylesheet" href="${publicBasePath}${path_1.default.posix.join(assetsDir, filename)}">`;
        if (/<\/head>/.test(html)) {
            return html.replace(/<\/head>/, `${tag}\n</head>`);
        }
        else {
            return tag + '\n' + html;
        }
    };
    const injectScript = (html, filename) => {
        filename = utils_1.isExternalUrl(filename)
            ? filename
            : `${publicBasePath}${path_1.default.posix.join(assetsDir, filename)}`;
        const tag = `<script type="module" src="${filename}"></script>`;
        if (/<\/body>/.test(html)) {
            return html.replace(/<\/body>/, `${tag}\n</body>`);
        }
        else {
            return html + '\n' + tag;
        }
    };
    const renderIndex = (root, cdn, cssFileName, bundleOutput) => {
        // inject css link
        processedHtml = injectCSS(processedHtml, cssFileName);
        // if not inlining vue, inject cdn link so it can start the fetch early
        if (cdn) {
            processedHtml = injectScript(processedHtml, vueResolver_1.resolveVue(root).cdnLink);
        }
        // inject js entry chunks
        for (const chunk of bundleOutput) {
            if (chunk.type === 'chunk' && chunk.isEntry) {
                processedHtml = injectScript(processedHtml, chunk.fileName);
            }
        }
        return processedHtml;
    };
    return {
        renderIndex,
        htmlPlugin
    };
};
// this extends the config in @vue/compiler-sfc with <link href>
const assetAttrsConfig = {
    link: ['href'],
    video: ['src', 'poster'],
    source: ['src'],
    img: ['src'],
    image: ['xlink:href', 'href'],
    use: ['xlink:href', 'href']
};
// compile index.html to a JS module, importing referenced assets
// and scripts
const compileHtml = async (html, publicBasePath, assetsDir, inlineLimit, resolver) => {
    const ast = compiler_dom_1.parse(html);
    let js = '';
    const s = new magic_string_1.default(html);
    const assetUrls = [];
    const viteHtmlTrasnfrom = (node, context) => {
        if (node.type === 1 /* ELEMENT */) {
            if (node.tag === 'script') {
                const srcAttr = node.props.find((p) => p.type === 6 /* ATTRIBUTE */ && p.name === 'src');
                if (srcAttr && srcAttr.value) {
                    // <script type="module" src="..."/>
                    // add it as an import
                    js += `\nimport ${JSON.stringify(srcAttr.value.content)}`;
                }
                else if (node.children.length) {
                    // <script type="module">...</script>
                    // add its content
                    // TODO: if there are multiple inline module scripts on the page,
                    // they should technically be turned into separate modules, but
                    // it's hard to imagine any reason for anyone to do that.
                    js += `\n` + node.children[0].content.trim() + `\n`;
                }
                // remove the script tag from the html. we are going to inject new
                // ones in the end.
                s.remove(node.loc.start.offset, node.loc.end.offset);
            }
            // For asset references in index.html, also generate an import
            // statement for each - this will be handled by the asset plugin
            const assetAttrs = assetAttrsConfig[node.tag];
            if (assetAttrs) {
                for (const p of node.props) {
                    if (p.type === 6 /* ATTRIBUTE */ &&
                        p.value &&
                        assetAttrs.includes(p.name) &&
                        !utils_1.isExternalUrl(p.value.content)) {
                        const url = utils_1.cleanUrl(p.value.content);
                        js += `\nimport ${JSON.stringify(url)}`;
                        if (utils_1.isStaticAsset(url)) {
                            assetUrls.push(p);
                        }
                    }
                }
            }
        }
    };
    compiler_dom_1.transform(ast, {
        nodeTransforms: [viteHtmlTrasnfrom]
    });
    // for each encountered asset url, rewrite original html so that it
    // references the post-build location.
    for (const attr of assetUrls) {
        const value = attr.value;
        const { url } = await buildPluginAsset_1.resolveAsset(resolver.requestToFile(value.content), publicBasePath, assetsDir, inlineLimit);
        s.overwrite(value.loc.start.offset, value.loc.end.offset, url);
    }
    return {
        html: s.toString(),
        js
    };
};
