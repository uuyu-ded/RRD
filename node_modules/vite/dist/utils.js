"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const lru_cache_1 = __importDefault(require("lru-cache"));
const stream_1 = require("stream");
const getETag = require('etag');
const httpRE = /^https?:\/\//;
exports.isExternalUrl = (url) => httpRE.test(url);
const imageRE = /\.(png|jpe?g|gif|svg|ico)(\?.*)?$/;
const mediaRE = /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/;
const fontsRE = /\.(woff2?|eot|ttf|otf)(\?.*)?$/i;
/**
 * Check if a file is a static asset that vite can process.
 */
exports.isStaticAsset = (file) => {
    return imageRE.test(file) || mediaRE.test(file) || fontsRE.test(file);
};
/**
 * Check if a request is an import from js (instead of fetch() or ajax requests)
 * A request qualifies as long as it's not from page (no ext or .html).
 * this is because non-js files can be transformed into js and import json
 * as well.
 */
exports.isImportRequest = (ctx) => {
    const referer = exports.cleanUrl(ctx.get('referer'));
    return /\.\w+$/.test(referer) && !referer.endsWith('.html');
};
exports.queryRE = /\?.*$/;
exports.hashRE = /\#.*$/;
exports.cleanUrl = (url) => url.replace(exports.hashRE, '').replace(exports.queryRE, '');
const moduleReadCache = new lru_cache_1.default({
    max: 10000
});
/**
 * Read a file with in-memory cache.
 * Also sets approrpriate headers and body on the Koa context.
 */
async function cachedRead(ctx, file) {
    const lastModified = (await fs_extra_1.default.stat(file)).mtimeMs;
    const cached = moduleReadCache.get(file);
    if (ctx) {
        ctx.set('Cache-Control', 'no-cache');
        ctx.type = path_1.default.basename(file);
    }
    if (cached && cached.lastModified === lastModified) {
        if (ctx) {
            ctx.etag = cached.etag;
            ctx.lastModified = new Date(cached.lastModified);
            if (ctx.get('If-None-Match') === ctx.etag) {
                ctx.status = 304;
            }
            // still set the content for *.vue requests
            ctx.body = cached.content;
        }
        return cached.content;
    }
    const content = await fs_extra_1.default.readFile(file, 'utf-8');
    const etag = getETag(content);
    moduleReadCache.set(file, {
        content,
        etag,
        lastModified
    });
    if (ctx) {
        ctx.etag = etag;
        ctx.lastModified = new Date(lastModified);
        ctx.body = content;
        ctx.status = 200;
    }
    return content;
}
exports.cachedRead = cachedRead;
/**
 * Read already set body on a Koa context and normalize it into a string.
 * Useful in post-processing middlewares.
 */
async function readBody(stream) {
    if (stream instanceof stream_1.Readable) {
        return new Promise((resolve, reject) => {
            let res = '';
            stream
                .on('data', (chunk) => (res += chunk))
                .on('error', reject)
                .on('end', () => {
                resolve(res);
            });
        });
    }
    else {
        return !stream || typeof stream === 'string' ? stream : stream.toString();
    }
}
exports.readBody = readBody;
